### **先用注解创建一个东西**
```java
/**  
 * 幂等注解，防止用户重复提交表单信息  
 */  
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface NoDuplicateSubmit {  
    String message() default "您操作太快，请稍后充实";  
}
```

**想要其生效，需要设置一个切面类拦截注解并读取其属性值后返回对应数据**
![[Pasted image 20251028163240.png]]
```xml
AOP的依赖配置
<dependency>
    <groupId>org.aspectj</groupId>      
    <artifactId>aspectjweaver</artifactId>
</dependency>
```

### **在java的joinPoint中存在如下四个部分**

| **方法​**​                   | ​**​作用​**​         |
| -------------------------- | ------------------ |
| `joinPoint.getSignature()` | 获取方法签名             |
| `joinPoint.getTarget()`    | 获取被调用的原始对象（不是代理对象） |
| `joinPoint.getArgs()`      | 获取方法调用时传入的实际参数值    |
| `joinPoint.proceed()`      | 继续执行被拦截的方法         |
**配置切面类**
```java
@Aspect
@RequiredArgsConstructor
public final class NoDuplicateSubmitAspect {
    private final RedissonClient redissonClient;

    /**
     ◦ 增强方法标记 {@link NoDuplicateSubmit} 注解逻辑
     */
@Around("@annotation(com.nageoffer.onecoupon.framework.idempotent.NoDuplicateSubmit)")
    public Object noDuplicateSubmit(ProceedingJoinPoint joinPoint) throws Throwable {
        NoDuplicateSubmit noDuplicateSubmit = getNoDuplicateSubmitAnnotation(joinPoint);
        // 获取分布式锁标识
        String lockKey = String.format("no-duplicate-submit:path:%s:currentUserId:%s:md5:%s", getServletPath(), getCurrentUserId(), calcArgsMD5(joinPoint));
        RLock lock = redissonClient.getLock(lockKey);
        // 尝试获取锁，获取锁失败就意味着已经重复提交，直接抛出异常
        if (!lock.tryLock()) {
            throw new ClientException(noDuplicateSubmit.message());
        }
        Object result;
        try {
            // 执行标记了防重复提交注解的方法原逻辑
            result = joinPoint.proceed();
        } finally {
            lock.unlock();
        }
        return result;
    }

    /**
     ◦ @return 返回自定义防重复提交注解

     */
    public static NoDuplicateSubmit getNoDuplicateSubmitAnnotation(ProceedingJoinPoint joinPoint) throws NoSuchMethodException {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method targetMethod = joinPoint.getTarget().getClass().getDeclaredMethod(methodSignature.getName(), methodSignature.getMethod().getParameterTypes());
        return targetMethod.getAnnotation(NoDuplicateSubmit.class);
    }

    /**
     ◦ @return 获取当前线程上下文 ServletPath
     */
    private String getServletPath() {
        ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        return sra.getRequest().getServletPath();
    }

    /**
     ◦ @return 当前操作用户 ID

     */
    private String getCurrentUserId() {
        // 用户属于非核心功能，这里先通过模拟的形式代替。后续如果需要后管展示，会重构该代码
        return "1810518709471555585";
    }

    /**
     ◦ @return joinPoint md5
     */
    private String calcArgsMD5(ProceedingJoinPoint joinPoint) {
        return DigestUtil.md5Hex(JSON.toJSONBytes(joinPoint.getArgs()));
    }
}
```

#### 初始化Aspect
**因为AOP配置放在其他模块，也就是starter组件库的内容
因此不能直接用注解放入Spring容器**
**而是需要手动创建自动装配类**

| **​方式​**​    | ​**​包扫描依赖​**​ | ​**​适用场景​**​ | ​**​Starter 可用性​**​ |
| ------------ | ------------- | ------------ | ------------------- |
| `@Component` | 必须包扫描匹配       | 主应用业务逻辑      | ❌ 失效                |
| `@Bean`      | 不依赖包扫描        | 任何场景         | ✅ 可靠                |
```java
@Configuration
public class IdempotentConfiguration{
    @Bean
    public NoDuplicateSubmitAspect noDuplicateSubmitAspect(RedissonClient redissonClient){
    return new NoDuplicateSubmitAspect(redissonClient);
    }
}
```

**为什么这里要专门传递一个redissonClient？**
因为@RequiredArgsConstructor实际上只是给了隐式构造器生成方法，真正的注入是由@Component实现的，而Starter情况下不能用@Component这种包扫描注解，因此需要自行注入。

**配置自动发现**
对于Starter组件库，必须使用此文件实现自动配置发现
在 Spring Boot 2.7+ 版本中，`METAINF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`文件用于 ​**​声明需要自动加载的配置类​**​
取代了旧版的 `spring.factories`方式。
如图所示
![[Pasted image 20251028171004.png|400]]

**最后在控制层放上自定义注解**
防重复提交的核心是 ​**​拦截重复的 HTTP 请求​**​，而不是防止业务逻辑重复执行。
HTTP 层的问题（如重复提交）应在 HTTP 层解决，而非渗透到业务逻辑。

|**层级​**​|​**​防重目标​**​|​**​典型场景​**​|
|---|---|---|
|​**​Controller​**​|拦截用户短时间内重复提交的相同请求|用户连续点击提交按钮、网络超时重试|
|​**​Service​**​|防止业务数据重复处理（如幂等设计）|消息队列重复消费、定时任务重复触发|
