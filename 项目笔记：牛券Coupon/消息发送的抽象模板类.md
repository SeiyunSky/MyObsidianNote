```java
采用<T>而非Object，可以保证类型安全
实现该抽象类的子类<T>这里换成子类需要处理的数据类型
public abstract class AbstractCommonSendProduceTemplate<T> {
```

```java
这里的<?>是更广义的类型替换符，<T>是基于类层面的，而<？>则是作为通配符，说明接受任何类型
使用Object子类需要进行类型转换才能使用，不好
protected abstract Message<?> buildMessage(T messageSendEvent, BaseSendExtendDTO requestParam);
```

### Environment去除硬编码？
```java
private final ConfigurableEnvironment environment;
```
`ConfigurableEnvironment`会从多个地方读取配置，按优先级排序：
1. **命令行参数**：`--server.port=8081`（最高优先级）
2. **JVM系统属性**：`-Dapp.name=myapp`
3. **操作系统环境变量**：`EXPORT APP_ENV=prod`
4. **配置文件**：`application-prod.yml`
5. **默认配置**：`application.yml`（最低优先级）
```java
// ❌ 硬编码方式（糟糕的设计）
String topic;
if (isDevEnvironment()) {
    topic = "coupon_topic_dev";
} else if (isTestEnvironment()) {
    topic = "coupon_topic_test";
} else {
    topic = "coupon_topic_prod";
}

// ✅ 使用Environment（优雅的设计）
String topic = "coupon_topic_${env:prod}";
topic = environment.resolvePlaceholders(topic);
```

## Message接口
直接发送数据对象或使用Map理论上可行，但是Message可以保持类型安全的情况下
输出更加完好的消息结构
```java
public interface Message<T> {  
    T getPayload();  
  
    MessageHeaders getHeaders();  
}
```
```json
{
  "headers": {
    "id": "a1b2c3d4",
    "timestamp": 1701000000000,
    "keys": "COUPON_TASK_123",
    "topic": "coupon_topic",
    "tag": "immediate"
  },
  "payload": {
    "taskId": 123,
    "templateId": 456,
    "userIdList": [1001, 1002, 1003]
  }
}
```

## 模板父类的设计
其中子类需要实现内部的抽象类
通用方法在调用时使用的是父类中实现的方法

| 逻辑位置        | 职责         | 示例                                                |
| ----------- | ---------- | ------------------------------------------------- |
| **父类（通用）**​ | 消息发送的固定流程  | 1. 构建目的地  <br>2. 选择发送方式  <br>3. 异常处理  <br>4. 日志记录 |
| **子类（具体）**​ | 特定消息的个性化配置 | 1. Topic名称  <br>2. 消息格式  <br>3. Headers设置         |
```java
@RequiredArgsConstructor  
@Slf4j(topic = "CommonSendProduceTemplate")  
public abstract class AbstractCommonSendProduceTemplate<T> {  
  
    private final RocketMQTemplate rocketMQTemplate;  
  
    /**  
     * 构建消息发送事件基础扩充属性实体  
     *  
     * @param messageSendEvent 消息发送事件  
     * @return 扩充属性实体  
     */  
    protected abstract BaseSendExtendDTO buildBaseSendExtendParam(T messageSendEvent);  
  
    /**  
     * 构建消息基本参数，请求头、Keys...  
     ** @param messageSendEvent 消息发送事件  
     * @param requestParam     扩充属性实体  
     * @return 消息基本参数  
     */  
    protected abstract Message<?> buildMessage(T messageSendEvent, BaseSendExtendDTO requestParam);  
  
    /**  
     * 消息事件通用发送  
     *  
     * @param messageSendEvent 消息发送事件  
     * @return 消息发送返回结果  
     */  
    public SendResult sendMessage(T messageSendEvent) {  
        BaseSendExtendDTO baseSendExtendDTO = buildBaseSendExtendParam(messageSendEvent);  
        SendResult sendResult;  
        try {  
            // 构建 Topic 目标落点 formats: topicName:tags            StringBuilder destinationBuilder = StrUtil.builder().append(baseSendExtendDTO.getTopic());  
            if (StrUtil.isNotBlank(baseSendExtendDTO.getTag())) {  
                destinationBuilder.append(":").append(baseSendExtendDTO.getTag());  
            }  
  
            // 延迟时间不为空，发送任意延迟消息，否则发送普通消息  
            if (baseSendExtendDTO.getDelayTime() != null) {  
                sendResult = rocketMQTemplate.syncSendDeliverTimeMills(  
                        destinationBuilder.toString(),  
                        buildMessage(messageSendEvent, baseSendExtendDTO),  
                        baseSendExtendDTO.getDelayTime()  
                );  
            } else {  
                sendResult = rocketMQTemplate.syncSend(  
                        destinationBuilder.toString(),  
                        buildMessage(messageSendEvent, baseSendExtendDTO),  
                        baseSendExtendDTO.getSentTimeout()  
                );  
            }  
  
            log.info("[生产者] {} - 发送结果：{}，消息ID：{}，消息Keys：{}", baseSendExtendDTO.getEventName(), sendResult.getSendStatus(), sendResult.getMsgId(), baseSendExtendDTO.getKeys());  
        } catch (Throwable ex) {  
            log.error("[生产者] {} - 消息发送失败，消息体：{}", baseSendExtendDTO.getEventName(), JSON.toJSONString(messageSendEvent), ex);  
            throw ex;  
        }  
  
        return sendResult;  
    }  
}
```


