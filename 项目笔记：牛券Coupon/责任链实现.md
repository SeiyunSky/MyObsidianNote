**首先，需要一个接口实现基本逻辑**
```java
这里继承Ordered实现排序，也可以在实现类上直接用@Ordered("数字")
public interface MerchantAdminAbstractChainHandler<T> extends Ordered{
    //这个是规定的责任链处理函数名
    void handler(T requestParam);
    //责任链组件标识
    String mark();
}
```

**实现类**
  ​**​约束参数类型​**​：声明该类只处理 `CouponTemplateSaveReqDTO`类型的请求，其他类型传入会​**​编译报错​**
  因此如果出现一条责任链需要**相互传递不同数据类型**，可以以此实现​
```java
//实现接口，并且放入对应的DTO
public class CouponTemplateCreateParamNotNullChainFilter implements MerchantAdminAbstractChainHandler<CouponTemplateSaveReqDTO>
```

**对应容器**
 **ApplicationContext**是 ​​Spring 框架的核心接口​，代表了 Spring 的 IoC（控制反转）容器​​，负责管理应用中所有的 Bean及其依赖关系。
   让 Bean 获取 Spring 容器的引用（`ApplicationContext`），从而动态访问其他 Bean 或容器功能。
**CommandLineRunner的作用与使用场景​**
  在 Spring Boot 应用​**​完全启动后​**​，执行一些初始化逻辑（如数据预热、资源加载，自带方法为run。
  可以用来进行缓存预热、消息队列监听、定时任务调度
```java
//这是一个静态方法类
public final class MerchantAdminChainContext<T> implements ApplicationContextAware, CommandLineRunner {
/**  
 * 应用上下文，我们这里通过 Spring IOC 获取 Bean 实例  
 */  
private ApplicationContext applicationContext;

//这是CommandLineRunner的方法，
public void run(String... args){
//从IOC容器中获取指定接口SpringBean集合
//存放到责任链容器中，根据顺序排序后即可使用
}

这里可以放上一个handler，也可以考虑把private的自定义容器改为public分开些，最终的作用都是作为一个主责任链来挨个调用底下的子实现类

//这是ApplicationContextAware必须实现的方法
@Override  
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
    this.applicationContext = applicationContext;  
}

}
```



