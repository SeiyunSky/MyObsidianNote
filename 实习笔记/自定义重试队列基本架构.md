重试发送用

**管理器**
```java
package com.manage.utils;  
  
import com.manage.bean.MQ4GC.PendingUploadTask;  
import com.manage.service.RetryWorker;  
  
import java.util.concurrent.*;  
import java.util.concurrent.atomic.AtomicInteger;  
  
public class RetryManager {  
    private static final RetryManager INSTANCE = new RetryManager();  
    private final DelayQueue<PendingUploadTask> retryQueue = new DelayQueue<>();  
    private final ThreadPoolExecutor workerThreadPool;  
    private final RetryWorker retryWorker;  
    private volatile boolean isRunning = false;  
  
    private final Object lifecycleLock = new Object();  
  
    public RetryManager() {  
        // 创建单线程线程池  
        this.workerThreadPool = new ThreadPoolExecutor(  
                1,      // corePoolSize: 核心线程数 = 1                1,      // maximumPoolSize: 最大线程数 = 1                0L,     // keepAliveTime: 空闲线程存活时间（单线程不需要回收）  
                TimeUnit.MILLISECONDS, // 时间单位  
                new LinkedBlockingQueue<>(100), // 任务队列  
                new RetryThreadFactory("retry-worker"), // 自定义线程工厂  
                new ThreadPoolExecutor.DiscardPolicy()  
        );  
        this.retryWorker = new RetryWorker(retryQueue);  
    }  
  
    public static RetryManager getInstance() {  
        return INSTANCE;  
    }  
  
    /**  
     * 启动重试管理器 - 在应用启动时调用  
     */  
    public void start() {  
        synchronized (lifecycleLock) {  
            if (isRunning) {  
                return;  
            }  
            isRunning = true;  
  
            // 启动工作线程  
            workerThreadPool.execute(retryWorker);  
  
            System.out.println("RetryManager started successfully");  
        }  
    }  
  
    public void addTask(PendingUploadTask task) {  
        if (!isRunning) {  
            throw new IllegalStateException("RetryManager 未启动");  
        }  
        retryQueue.put(task);  
        System.out.println("添加任务: " + task.getTaskId());  
    }  
  
    /**  
     * 停止重试管理器 - 在应用关闭时调用  
     */  
    public void stop() {  
        synchronized (lifecycleLock) {  
            if (!isRunning) {  
                return;  
            }  
            isRunning = false;  
  
            // 先停止 RetryWorker            retryWorker.setRunning(false);  
  
            // 中断线程池中的线程  
            workerThreadPool.shutdownNow();  
  
            // 清空队列  
            retryQueue.clear();  
  
            System.out.println("RetryManager stopped successfully");  
        }  
    }  
  
    //自定义线程池  
    private static class RetryThreadFactory implements ThreadFactory {  
        private final String namePrefix;  
        private final AtomicInteger threadCount = new AtomicInteger(1);  
        public RetryThreadFactory(String namePrefix) {  
            this.namePrefix = namePrefix;  
        }  
        @Override  
        public Thread newThread(Runnable r) {  
            Thread thread = new Thread(r, namePrefix + "-" + threadCount.getAndIncrement());  
            thread.setDaemon(true);  
            thread.setPriority(Thread.NORM_PRIORITY);  
            return thread;  
        }  
    }  
}
```

**管理器配置**
```java
package com.manage.api.group.gangcheng.bean.MQ4GC;  
  
import com.manage.api.group.gangcheng.utils.RetryManager;  
import jakarta.annotation.PostConstruct;  
import jakarta.annotation.PreDestroy;  
import org.springframework.context.annotation.Configuration;  
  
@Configuration  
public class RetryManagerConfig {  
    private final RetryManager retryManager;  
    public RetryManagerConfig() {  
        this.retryManager = RetryManager.getInstance();  
    }  
  
    @PostConstruct  
    public void init() {  
        retryManager.start();  
    }  
  
    @PreDestroy  
    public void destroy() {  
        retryManager.stop();  
    }  
}
```

**消费者**
```java
package com.manage.api.group.gangcheng.service;  
  
import com.manage.api.group.gangcheng.bean.MQ4GC.PendingUploadTask;  
import lombok.Setter;  
  
import java.util.concurrent.DelayQueue;  
  
/**  
 * 独立的重试工作线程  
 */  
public class RetryWorker implements Runnable {  
  
    private final DelayQueue<PendingUploadTask> retryQueue;  
    @Setter  
    private volatile boolean isRunning = false;  
  
    public RetryWorker(DelayQueue<PendingUploadTask> retryQueue) {  
        this.retryQueue = retryQueue;  
    }  
  
    @Override  
    public void run() {  
        System.out.println("RetryWorker 启动");  
        isRunning = true;  
  
        while (isRunning && !Thread.currentThread().isInterrupted()) {}  
  
    }  
  
    private boolean executeRetry(PendingUploadTask task) {  
        return true;  
    }  
  
    private void handleSuccess(PendingUploadTask task) {  
        System.out.println("任务成功: " + task.getTaskId());  
        // 这里可以添加成功后的后续逻辑  
    }  
  
    private void handleFailure(PendingUploadTask task) {  
        System.out.println("任务最终失败: " + task.getTaskId());  
        // 这里可以添加到死信队列或记录日志  
    }  
}
```

**消费的产品**
这里因为业务需求，所以我考虑的是使用延迟队列解决
需要实现Delayed接口和里面的getDelay与compareTo方法
```java
package com.manage.api.group.gangcheng.bean.MQ4GC;  
  
import lombok.AllArgsConstructor;  
import lombok.Builder;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.concurrent.Delayed;  
import java.util.concurrent.TimeUnit;  
  
@Data  
@Builder  
@AllArgsConstructor  
@NoArgsConstructor  
public class PendingUploadTask implements Delayed {  
    private String taskId;  
  
    private String cityDept;  
  
    private String platForm;  
  
    private String parkArea;  
  
    private String record;  
  
    private String lane;  
  
    private String createTime;  
  
    private long nextRetryTime;  
  
    @Override  
    public long getDelay(TimeUnit unit) {  
        return 5000;  
    }  
  
    @Override  
    public int compareTo(Delayed o) {  
        return Long.compare(  
                this.getNextRetryTime(),          // 当前任务的到期时间  
                ((PendingUploadTask) o).getNextRetryTime() // 另一个任务的到期时间  
        );  
    }  
}
```

