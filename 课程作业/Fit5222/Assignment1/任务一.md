# 第一题解题方案总结
## 问题概述
第一题的目标是在 Flatland 铁路环境中实现一个单智能体（火车）的寻路算法。任务是在不考虑与其他智能体碰撞的情况下，为单个智能体找到一条从给定的起始位置和方向到目标终点的有效且最优的路径。
## 所用算法：A* (A-Star) 搜索算法
为了解决此问题，我们采用了经典的 **A* (A-Star) 搜索算法**。A* 算法是一种非常著名且高效的寻路算法，它能保证在存在路径的情况下，一定能找到最短路径。
### 为何选择 A*?
- **最优性 (Optimal):** 如果所用的启发函数是“可采纳的”（即它从不估计过高的代价），A* 算法保证能找到成本最低的路径（在此问题中即为最短路径）。
- **完备性 (Complete):** 如果解决方案存在，A* 算法一定能找到它。
- **高效性 (Efficient):** 通过使用启发函数来引导其搜索方向，A* 算法相比于无信息搜索算法（如广度优先搜索）探索的地图区域要小得多，因此在大多数情况下速度更快。

### 实现核心思想
A* 算法通过一个评估函数 f(n) = g(n) + h(n) 来选择要探索的节点。  
其中：
- g(n) 是从起点到当前节点 n 的实际移动代价。
- h(n) 是从节点 n 到终点的预估（启发式）代价。

我们实现的关键部分包括：
#### 1. 状态表示
在 Flatland 环境中，仅使用 (row, col) 坐标不足以定义一个状态，因为从一个单元格出发的可用移动选项取决于智能体进入该单元格的方向。因此，一个状态由一个三元组来唯一确定：**(row, col, direction)**。
#### 2. 启发函数 (h(n))
我们使用 **曼哈顿距离** 作为启发函数。它计算当前位置与目标点在 x 和 y 坐标上差值的绝对值之和。对于只能上下左右移动的网格世界，这是一个完美的启发函数，因为它计算成本低，并且永远不会高估实际距离。
```python
def heuristic(pos, goal):
    return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])
```
#### 3. 数据结构
- **开放列表 (Open Set):** 使用 **优先队列（最小堆）** 来存储待访问的节点。它能以高效率获取 f_score 最低的节点，这对算法的性能至关重要。
- **came_from 字典:** 该字典用于存储每个被访问节点的前驱节点，以便在到达终点后能够回溯并重建完整路径。
- **g_score 字典:** 该字典用于存储每个已访问状态的 g_score（从起点到该状态的最低成本），以避免重复计算。
## 代码结构
解决方案主要包含在 get_path 函数以及两个辅助函数中。
- get_path(...): 主函数，负责初始化数据结构并执行 A* 算法的主循环。它不断地探索邻近节点，计算它们的评分，并将它们添加到优先队列中，直到找到目标。
- heuristic(...): 用于计算曼哈顿距离的辅助函数。
- reconstruct_path(...): 该辅助函数在找到终点后，利用 came_from 字典从终点开始回溯，最终构建出表示路径的坐标列表。
## 总结
实践证明，所实现的 A* 算法非常有效，它成功地为所有测试用例找到了最优（最短）路径，成功率达到了 100%。测试结果验证了我们对状态的表示、启发函数的选择以及整体算法逻辑的正确性。

# 第二题解题方案总结
## 问题概述
第二题将问题的复杂度从简单的寻路任务提升到了包含 **动态障碍规避** 的层面。虽然仍然是每次只为一个智能体规划路径，但算法现在必须找到一条无冲突的路径，同时要考虑到环境中已经存在的其他智能体（障碍物）的预定移动轨迹。
## 所用算法：感知时间的 A* 搜索 (Time-Aware A* / 带时空预留表的 A*)
本解决方案将第一题的 A* 算法扩展为了一个 **感知时间的 A* 搜索 (Time-Aware A* Search)**。该方法将 **时间** 维度直接整合进了寻路逻辑中，将问题从一个二维空间搜索转变为一个三维的时空搜索。
### 为何选择感知时间的 A*?
- **处理动态障碍：** 一个只在 (x, y) 坐标上运行的标准 A* 算法无法检测与时间相关的碰撞。通过将时间加入状态，我们可以在每个特定的时间步检查冲突。
- **保持最优性：** 该算法的目标仍然是找到时间上最短的路径（在无权重的网格中，这等同于路径长度）。启发函数继续有效地引导搜索朝向目标前进。
### 相比第一题的核心改动

本次实现对原始 A* 算法引入了三个关键的修改：

#### 1. 感知时间的状态表示
状态的定义被扩展以包含时间。一个状态不再仅仅是 (row, col, direction)，而是由一个四元组 **(row, col, direction, time)** 来唯一确定。这是让算法能够推理一个智能体“在何时”位于某个位置的基础性改变。
#### 2. 使用“时空预留表”进行碰撞检测
为了高效地检查碰撞，我们首先将 existing_paths 预处理成一个 **时空预留表 (Reservation Table)**。该表在技术上通过 Python 的 set 实现，以获得 O(1) 的平均查找时间复杂度。
- **工作原理：** 在搜索开始前，我们遍历所有已存在的路径，并将每一个被占用的时空坐标点 (row, col, time) 添加到 reserved_locations 集合中。
- **处理的碰撞类型：**
    - **顶点冲突：** 如果另一个智能体在 time 时刻已经位于 (x, y)，那么当前智能体不能移动到该位置。通过 (x, y, time) in reserved_locations 检查。
    - **迎面/交换冲突：** 为了防止两个智能体在同一时间步交换相邻单元格，我们同样也预留了发生移动的这个过程。
- **优势：** 这个预处理步骤避免了在 A* 主循环中反复遍历 existing_paths，极大地提升了算法性能。
#### 3. 扩展动作空间：增加“等待”动作
在动态环境中，有时最优的行动是“原地不动”。我们扩展了智能体的可选动作，加入了在其当前位置 **等待一个时间步** 的选项。
- **实现：** 在 A* 循环的每次迭代中，除了探索有效的移动方向外，我们还会评估一个“等待”状态。在该状态下，位置和方向保持不变，但 time 增加 1。
- **重要性：** 这个动作对于解决那些必须让其他智能体先行通过才能继续前进的冲突至关重要。

## 代码结构
- get_path(...): 主函数现在接收 existing_paths 参数。它首先构建时空预留表，然后执行感知时间的 A* 循环。在循环内部，它会对每一个可能的动作（包括等待）进行碰撞检测，然后才将新状态加入优先队列。
- reconstruct_path(...): 这个辅助函数基本保持不变，但现在它回溯的状态路径中包含了时间维度。
- **剪枝:** 代码中包含了一个 if current_time >= max_timestep: 的检查，用于剪掉那些超出最大时间限制的分支，防止无限循环。
## 总结
通过将标准 A* 算法改造为感知时间的搜索算法，并使用高效的时空预留表进行碰撞检测，本方案成功地引导智能体在动态环境中穿行。它能够可靠地找到通往目标的无冲突路径，或者在给定约束下路径不存在时正确地返回一个空列表。

# 第三题解题方案总结

## 问题概述

第三题提出了一个真正的 **多智能体路径规划 (MAPF)** 挑战，要求在一个动态环境中为所有智能体同时规划无冲突的路径。此外，执行过程中引入的随机故障，以及由此产生的 replan (重新规划) 函数需求，进一步增加了问题的复杂性。

## 所用算法：带有增强功能的优先级规划

为了解决这个 MAPF 问题，我们实现了一个 **优先级规划 (Prioritized Planning)** 框架。我们选择这种解耦方法，是因为它在实现复杂度和求解效率之间取得了极佳的平衡。其核心思想是为所有智能体建立一个优先级顺序，然后逐个规划路径。每当一个智能体的路径规划完成后，该路径就成为所有后续低优先级智能体必须避开的动态障碍物。

每个智能体的核心路径规划由在第二题中开发的 **感知时间的A*搜索 (Time-Aware A*)** 算法负责，该算法在一个三维的时空状态 (x, y, 方向, 时间) 下运行。

### 关键性能瓶颈：病态测试用例

在测试过程中，我们发现了一个关键的性能瓶颈。在某些特定的复杂场景下，Plan Time (规划时间) 从毫秒级骤增至近30秒。

- **根本原因：** 这个问题的根源在于，当一个低优先级的智能体被高优先级智能体的路径困住时，我们的 A* 算法会陷入一个“计算陷阱”。它会无休止地探索“等待”这一动作，导致其搜索空间（即 open_set 优先队列）中充满了数以万计的、几乎无效的状态，最终引发性能雪崩。
    

### 解决方案：徒劳剪枝 (Futility Pruning)

为了解决这一问题，我们在核心规划函数 plan_single_agent_path 中引入了一项至关重要的优化——**徒劳剪枝 (Futility Pruning)**。

- **目的：** 徒劳剪枝的目标是防止算法在那些明显没有希望的搜索分支上浪费计算资源。
    
- **工作机制：**
    
    1. 引入一个 visit_count 字典，用于追踪每个 **物理状态**（由 x, y, 方向 定义）被从优先队列中取出并扩展的次数。
        
    2. 设定一个 FUTILITY_THRESHOLD 阈值（例如 150）作为算法的“耐心极限”。
        
    3. 在 A* 循环的内部，扩展一个状态之前，检查其对应的物理状态的访问次数。如果次数超过阈值，算法就判断自己陷入了死循环，并立即使用 continue 关键字剪掉这个分支，果断放弃这条没有希望的路径。
        

这个简单而强大的启发式方法，确保了规划器在遇到“病态”难题时能够“快速失败”而不是被卡住，从而维持了整体的高性能。

## 核心函数实现

- **get_path (初始规划):**
    
    1. **优先级排序：** 根据智能体距离目标的曼哈顿距离进行排序，距离越短，优先级越高。
        
    2. **顺序规划：** 算法遍历排好序的列表，为每个智能体调用核心的 A* 规划器，并将所有已规划好的路径作为动态障碍物存入一个时空预留表中。
        
- **replan (动态重新规划):**
    
    1. **重新排序优先级：** 当重规划被触发时，优先级被重置。新发生故障的智能体拥有最高优先级，其次是上一步执行失败的智能体。
        
    2. **构建预留表：** 为重规划任务构建一个新的时空预留表，其中包含：
        
        - 所有正常智能体的未来路径。
            
        - 故障智能体在故障期间的“原地等待”轨迹。
            
    3. **执行重规划：** 随后，根据新的优先级顺序，再次调用核心的 A* 规划器，为需要重规划的智能体生成从当前状态出发的、新的无冲突路径段。
        

## 总结

最终的解决方案是一个健壮且高效的优先级规划系统。通过实现一个标准的 MAPF 算法，并利用关键的 **徒劳剪枝** 机制对其进行增强，我们成功地在“寻找可行路径”和“避免复杂场景下的性能瓶颈”这两个需求之间取得了平衡。该系统展示了生成初始计划并在执行中动态适应突发事件的能力。
