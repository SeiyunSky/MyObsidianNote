## 基本语法
**ScriptableObject**——创建可序列化的数据容器，用来存储数据，不依赖于GameObejct
**MonoBehaviour**——需要依附场景对象存在
### **关键字**：
  **yield return** 
    C# 关键字，用于**迭代器方法**，不会直接结束方法，而是记住当前执行的位置，下次调用时继续。

 `IEnumerable`和`IEnumerator`
    前者表示数据集合，后者用于遍历数据集合
   ```C#
   public IEnumerator AddCard(CardView card)
   {
      cards.Add(card);
      yield return UpdateCard();
   }
   所以这个代码指的是执行添加至卡组，并返回更新后卡组作为当前值
   ```
 **readonly** 
    只读字段，允许字段在初始化后不能被修改，和java的final在字段修饰时效果一样

### 基本函数
#### 生命周期函数
**初始化阶段**
  ```c#
  void Awake()
  {
    // 脚本加载时调用（最早）
    // 用于初始化变量、获取组件引用
  }

  void Start()
  {
    // 在所有Awake之后，第一帧更新前调用
    // 用于游戏逻辑初始化
  }

  void OnEnable()
  {
    // 当对象变为激活状态时调用
  }

  void OnDisable()
  {
    // 当对象变为非激活状态时调用
  }
  ```

**更新循环**
 ```C#
 void Update()
 {
    // 每帧调用一次（约60次/秒）
    // 用于游戏逻辑、输入检测
 }

 void FixedUpdate()
 { 
    // 固定时间间隔调用（默认0.02秒）
    // 用于物理计算
 }

 void LateUpdate()
 {
    // 在所有Update之后调用
    // 用于相机跟随等操作
 }
 ```

**结束阶段**
 ```C#
 void OnDestroy()
 {
    // 对象被销毁时调用
    // 用于清理资源
 }

 void OnApplicationQuit()
 {
    // 应用程序退出时调用
 }
 ```

#### 输入处理函数
```C#
void Update()
{
    // 键盘输入
    if (Input.GetKeyDown(KeyCode.Space))
    {
        // 空格键按下
    }
    
    if (Input.GetKey(KeyCode.W))
    {
        // W键持续按住
    }
    
    // 鼠标输入
    if (Input.GetMouseButtonDown(0))
    {
        // 鼠标左键点击
    }
    
    // 获取鼠标位置
    Vector3 mousePos = Input.mousePosition;
    // 获取轴输入（平滑输入）
    float horizontal = Input.GetAxis("Horizontal");
    float vertical = Input.GetAxis("Vertical");
}
```

#### 变换位移与组件获取与实例化和销毁
```c#
void Update()
{
    // 基本移动方式
    transform.Translate(Vector3.forward * Time.deltaTime * speed);
    
    // 旋转
    transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);
    
    // 直接设置位置和旋转
    transform.position = new Vector3(x, y, z);
    transform.rotation = Quaternion.Euler(0, angle, 0);
    
    // 看向目标
    transform.LookAt(target);
}

void Start()
{
    // 获取自身组件
    Rigidbody rb = GetComponent<Rigidbody>();
    Renderer renderer = GetComponent<Renderer>();
    
    // 获取子对象组件
    Transform child = transform.Find("ChildName");
    Renderer childRenderer = GetComponentInChildren<Renderer>();
    
    // 获取父对象组件
    Transform parent = transform.parent;
    
    // 通过标签查找对象
    GameObject player = GameObject.FindWithTag("Player");
    
    // 查找所有特定类型的对象
    Enemy[] allEnemies = FindObjectsOfType<Enemy>();
}

void SpawnObject()
{
    // 实例化预制体
    GameObject newObject = Instantiate(prefab, position, rotation);
    
    // 设置父对象
    newObject.transform.SetParent(parentTransform);
}

void DestroyObject()
{
    // 销毁对象
    Destroy(gameObject);
    
    // 延迟销毁
    Destroy(gameObject, 3f); // 3秒后销毁
}
```

## 编辑器增强特性
`[CreateAssetMenu]`是 Unity 中的一个 ​**​特性（Attribute）​**​，它允许你在 Unity 编辑器的 ​**​右键创建菜单​**​ 中添加一个新的菜单项，用来快速创建特定类型的 ScriptableObject 资源文件。
```C#
[CreateAssetMenu(menuName = "Data/Card")]
public class CardData : ScriptableObject
{
}
```
 **`[Range]`- 滑块控制​**
 **`[PreloadAsset]`- 预加载资源**
 **`[Tooltip]`- 鼠标悬停提示​**
 **`[Header]`/ `[Space]`- 组织Inspector​
 `[field: SerializeField]`+ `{ get; private set; }`——解决在Unity编译器控制+读写控制

## 事件框架
partial 关键词可以用来分模块定义事件
```C#
Assets/
└── Scripts/
    ├── Events/                  # 事件系统核心
    │   ├── EventManager.cs       # 全局事件管理器
    │   ├── GameEvents.cs         # 静态事件定义（推荐用partial类分模块）
    │   └── AudioEvents.cs        # 音频相关事件（示例）
    │
    ├── Systems/                 # 各系统的事件监听与触发
    │   ├── Player/
    │   │   ├── PlayerHealth.cs   # 玩家生命（触发受伤事件）
    │   │   └── PlayerInput.cs    # 输入控制（触发技能事件）
    │   │
    │   └── UI/
    │       └── HealthBarUI.cs    # 监听玩家受伤事件更新血条
    │
    └── Utilities/               # 可选工具
        └── EventExtensions.cs    # 事件相关的扩展方法
```
## Dotween
```c#
移动到xx位置
DOMove(position,time)
```

## 一些小知识
**Ray 射线 配合RayCast做射线检测**
检测层级\相机发射射线\物体发射射线（哇塞是子弹）
```C#
    if (Input.GetMouseButtonDown(0)) { 
    // 鼠标左键点击
        Ray ray = Camera
        .main.ScreenPointToRay(Input.mousePosition); 
        // 从屏幕发射射线
        RaycastHit hit; 
        // 存储碰撞信息

        if (Physics.Raycast(ray, out hit)) { 
        // 检测射线是否碰撞
            Debug
            .Log("点击了: " 
            + hit.collider.gameObject.name); 
              // 输出碰撞物体名字
        }
    }
```
**Camera里的常用属性和方法**
**比方说可以通过相机位置的变换造出震动感**
```c#
// 视野角度（第一人称游戏常用）
Camera.main.fieldOfView = 60f;
// 裁剪平面（近处和远处可见范围）
Camera.main.nearClipPlane = 0.1f;  // 最近能看到多近
Camera.main.farClipPlane = 1000f;  // 最远能看到多远

-----------------------------------------------------
// 渲染目标，本质上是一个自定义的播放区域
Camera.main.targetTexture = renderTexture;

public Camera miniMapCamera;  //相机
public RawImage miniMapDisplay;  //UIView
-比方说用来做小地图-
RenderTexture rt = new RenderTexture(256, 256, 16); miniMapCamera.targetTexture = rt; miniMapDisplay.texture = rt;

public Camera mirrorCamera;
public RenderTexture mirrorTexture;
public Material mirrorMaterial; // 镜子的材
-比方说作为镜子-
mirrorCamera.targetTexture = mirrorTexture;
//renderTexture存画面，Camera的targetTexture绑定render
//再把材料的Texture用render代替
//就可以在Update对镜子相机的位置进行更新
----------------------------------------------------

// 相机变换组件（最常用！）
Transform camTransform = Camera.main.transform;
// 获取相机的前后左右方向
Vector3 forward = camTransform.forward;  // 前方向
Vector3 right = camTransform.right;      // 右方向
Vector3 up = camTransform.up;            // 上方向
Vector3 position = camTransform.position; // 相机位置

Camera.main.ScreenPointToRay() 射线交互
```


