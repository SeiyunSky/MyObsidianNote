
**一句话总结**

|接口/类|核心功能|适用场景|
|---|---|---|
|`Executor`|提交任务|简单异步执行|
|`ExecutorService`|任务管理、结果获取|需要任务结果或批量控制|
|`ScheduledExecutorService`|定时任务|心跳检测、定时刷新|
|`ThreadPoolExecutor`|定制线程池|资源限制、监控|
|`ForkJoinPool`|分治任务|并行计算、递归分解|

### 创建线程池
`ExecutorService`是 Java 提供的一个 ​**​线程池接口​**​，用于管理和执行多个异步任务（比如多线程处理消息、并发请求等）。你可以把它想象成一个 ​**​“任务调度中心”​**​，它负责分配线程来执行你提交的任务，避免频繁创建和销毁线程的开销。

**自定义线程工厂的作用是控制线程池中线程的创建过程​**​，比如给线程起名字、设为守护线程、设置优先级等，让线程更符合你的业务需求，同时便于调试和监控。
- ​**​​**​守护线程的特点​**​：如果 JVM 中只剩守护线程在运行，JVM 会直接退出（不会等它们执行完）。
- **index.incrementAndGet()**用原子计数器确保线程名字中的数字不重复
```java
@Bean
public ExecutorService asyncStreamConsumer() {
    int processors = Runtime.getRuntime().availableProcessors(); // 获取CPU核心数
    return new ThreadPoolExecutor(
        processors,                      // 核心线程数（常驻线程）
        processors + (processors >> 1),  // 最大线程数（核心数 × 1.5）
        60, TimeUnit.SECONDS,           // 空闲线程存活时间
        new LinkedBlockingQueue<>(),     // 任务队列（无界队列）
        runnable -> {                    // 自定义线程工厂
            Thread thread = new Thread(runnable);
            thread.setName("stream_consumer_" + index.incrementAndGet());
            thread.setDaemon(true);      // 设置为守护线程
            return thread;
        }
    );
}
```

| 参数                      | 作用                        | 示例值                                          |
| ----------------------- | ------------------------- | -------------------------------------------- |
| ​**​corePoolSize​**​    | 核心线程数（即使空闲也不会销毁）          | `Runtime.getRuntime().availableProcessors()` |
| ​**​maximumPoolSize​**​ | 最大线程数（队列满时才会创建新线程，直到达到此值） | `核心数 × 1.5`                                  |
| ​**​keepAliveTime​**​   | 非核心线程的空闲存活时间（超时后销毁）       | `60, TimeUnit.SECONDS`                       |
| ​**​workQueue​**​       | 任务队列（存放待执行的任务）            | `new LinkedBlockingQueue<>()`                |
| ​**​threadFactory​**​   | 自定义线程创建逻辑（如设置线程名、优先级等）    | 见代码示例                                        |


| 线程池类型                        | 特点                     | 适用场景              |
| ---------------------------- | ---------------------- | ----------------- |
| ​**​FixedThreadPool​**​      | 固定线程数，无界队列             | 长期运行的任务（如服务器请求处理） |
| ​**​CachedThreadPool​**​     | 线程数无限（按需创建），空闲线程60秒后销毁 | 短时高并发任务           |
| ​**​SingleThreadExecutor​**​ | 只有一个线程，顺序执行任务          | 需要顺序执行的场景（如日志写入）  |
| ​**​ScheduledThreadPool​**​  | 支持定时或周期性任务             | 定时任务（如心跳检测）       |

## ​**​1. `Executor`接口​**​

### ​**​作用​**​

最简单的线程池接口，只定义了一个方法：

​**​`void execute(Runnable command)`​**​

用于提交任务（`Runnable`），但不提供任务结果或生命周期管理。
- 仅需异步执行任务，不关心结果或状态。
```java
Executor executor = Executors.newSingleThreadExecutor();
executor.execute(() -> System.out.println("Task running"));
```

## **2. `ExecutorService`接口（最常用）​**​

继承自 `Executor`，​**​扩展了任务管理、结果获取和线程池关闭功能​**​。
- 需要任务结果、批量任务管理或线程池生命周期控制。

|方法|作用|
|---|---|
|​**​`Future<?> submit(Runnable task)`​**​|提交任务，返回 `Future`（可跟踪状态）。|
|​**​`Future<T> submit(Callable<T> task)`​**​|提交带返回值的任务（`Callable`）。|
|​**​`List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`​**​|批量提交任务，等待所有完成。|
|​**​`T invokeAny(Collection<Callable<T>> tasks)`​**​|提交多个任务，返回第一个成功的结果。|
|​**​`shutdown()`​**​|优雅关闭（等待已提交任务完成）。|
|​**​`shutdownNow()`​**​|强制关闭（尝试中断所有线程）。|
```java
ExecutorService executor = Executors.newFixedThreadPool(2);

// 提交 Runnable（无返回值）
Future<?> future1 = executor.submit(() -> System.out.println("Task 1"));

// 提交 Callable（有返回值）
Future<String> future2 = executor.submit(() -> "Task 2 result");

// 获取结果（阻塞）
String result = future2.get(); 

executor.shutdown();
```
### ​**​`ThreadPoolExecutor`类​**​
​**​`ExecutorService`的默认实现类​**​，允许精细控制线程池参数（核心线程数、队列类型等）。

| ​**​`corePoolSize`​**​             | 核心线程数（即使空闲也不会销毁）。              |
| ---------------------------------- | ------------------------------ |
| ​**​`maximumPoolSize`​**​          | 最大线程数（队列满时创建新线程，直到此值）。         |
| ​**​`keepAliveTime`​**​            | 非核心线程的空闲存活时间。                  |
| ​**​`workQueue`​**​                | 任务队列（如 `LinkedBlockingQueue`）。 |
| ​**​`threadFactory`​**​            | 自定义线程创建逻辑（如设置线程名）。             |
| ​**​`RejectedExecutionHandler`​**​ | 任务拒绝策略（队列和线程池满时的处理方式）。         |
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2,                              // 核心线程数
    4,                              // 最大线程数
    60, TimeUnit.SECONDS,           // 空闲线程存活时间
    new LinkedBlockingQueue<>(10),   // 任务队列（容量10）
    
    Executors.defaultThreadFactory(), // 默认线程工厂
    runnable -> {                    // 自定义线程工厂
            Thread thread = new Thread(runnable);
            thread.setName("stream_consumer_" + index.incrementAndGet());
            thread.setDaemon(true);      // 设置为守护线程
            return thread;
        }
    
    new ThreadPoolExecutor.AbortPolicy() // 拒绝策略（直接抛异常）
);
executor.submit(() -> System.out.println("Task running"));
```


## **3. `ScheduledExecutorService`接口​**​

继承自 `ExecutorService`，​**​支持定时和周期性任务​**​。
- 定时任务（如心跳检测、缓存刷新）。

| ​**​`schedule(Runnable command, long delay, TimeUnit unit)`​**​                                  | 延迟执行一次。                  |
| ------------------------------------------------------------------------------------------------ | ------------------------ |
| ​**​`scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`​**​   | 固定速率周期性执行（间隔包含任务执行时间）。   |
| ​**​`scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)`​**​ | 固定延迟周期性执行（间隔从任务完成后开始计算）。 |
```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

// 延迟 5 秒后执行
scheduler.schedule(() -> System.out.println("Delayed task"), 5, TimeUnit.SECONDS);

// 每隔 1 秒执行一次（固定速率）
scheduler.scheduleAtFixedRate(() -> System.out.println("Fixed rate"), 0, 1, TimeUnit.SECONDS);

// 任务完成后延迟 2 秒再执行下一次
scheduler.scheduleWithFixedDelay(() -> System.out.println("Fixed delay"), 0, 2, TimeUnit.SECONDS);
```
## 4 **`ForkJoinPool`类​**
**专为分治任务设计的线程池​**​，适合递归分解任务（如并行计算）

|方法|作用|
|---|---|
|​**​`invoke(ForkJoinTask<T> task)`​**​|执行任务并返回结果。|
|​**​`submit(ForkJoinTask<T> task)`​**​|提交任务，返回 `ForkJoinTask`。|
```java
ForkJoinPool forkJoinPool = new ForkJoinPool(4); // 并行度=4
long result = forkJoinPool.invoke(new RecursiveTask<Long>() {
    @Override
    protected Long compute() {
        // 分治逻辑（如归并排序）
        return 42L;
    }
});
```
## **拒绝策略（`RejectedExecutionHandler`）​**
|策略|行为|
|---|---|
|​**​`AbortPolicy`（默认）​**​|直接抛 `RejectedExecutionException`。|
|​**​`CallerRunsPolicy`​**​|让提交任务的线程自己执行。|
|​**​`DiscardPolicy`​**​|静默丢弃任务。|
|​**​`DiscardOldestPolicy`​**​|丢弃队列中最旧的任务，然后重试提交。|
