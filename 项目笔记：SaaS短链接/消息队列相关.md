应用模块的解耦、消息的异步化、削峰填谷
1、**为什么使用** Redis **充当消息队列**
    轻量级实现方式

2、**实现消息队列的方式**
[消息队列](https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw)
![[Pasted image 20250812201412.png]]

**创建StreamKey**
```redis
XADD Stream名称 * "键" "值"
XADD "short_link:stats-stream" * "New key" "New value"
```
**创建消费者组**
```redis
Xgroup create 结构体 结构体名
xgroup create short_link:stats-stream short_link:stats-stream:only-group 0
```

### **自定义线程池**
```java
@Bean
public ExecutorService asyncStreamConsumer() {
    int processors = Runtime.getRuntime().availableProcessors(); // 获取CPU核心数
    return new ThreadPoolExecutor(
        processors,                      // 核心线程数（常驻线程）
        processors + (processors >> 1),  // 最大线程数（核心数 × 1.5）
        60, TimeUnit.SECONDS,           // 空闲线程存活时间
        new LinkedBlockingQueue<>(),     // 任务队列（无界队列）
        runnable -> {                    // 自定义线程工厂
            Thread thread = new Thread(runnable);
            thread.setName("stream_consumer_" + index.incrementAndGet());
            thread.setDaemon(true);      // 设置为守护线程
            return thread;
        }
    );
}
```
### ​**​Redis Stream 消息监听容器配置创建代码解析​**
```java
@Bean(initMethod = "start", destroyMethod = "stop")
public StreamMessageListenerContainer<String, MapRecord<String, String, String>> streamMessageListenerContainer( ExecutorService asyncStreamConsumer ){// 注入自定义线程池
}
```
- ​**​`initMethod="start"`​**​：Bean 初始化后自动调用 `start()`方法，开始监听消息。
- ​**​`destroyMethod="stop"`​**​：Bean 销毁时自动调用 `stop()`方法，停止监听并释放资源。
- ​**​`ExecutorService asyncStreamConsumer`​**​：使用自定义线程池（你之前定义的）执行消息拉取和处理任务。

**监听容器配置​**
​​- `MapRecord`的作用​**​：将 Redis 的原始消息包装成 Java 对象，方便操作字段和值。
```java
StreamMessageListenerContainerOptions<String, MapRecord<String, String, String>> options =
    StreamMessageListenerContainerOptions.builder()
        .batchSize(10)                      // 每次最多拉取 10 条消息
        .executor(asyncStreamConsumer)      // 用自定义线程池执行消息拉取逻辑
        .pollTimeout(Duration.ofSeconds(3)) // 没有消息时阻塞等待 3 秒
        .build();
```

**创建监听容器​**
```java
StreamMessageListenerContainer<String, MapRecord<String, String, String>> container =
    StreamMessageListenerContainer.create(redisConnectionFactory, options);
```
- ​**​`redisConnectionFactory`​**​：Spring 自动注入的 Redis 连接工厂，用于和 Redis 通信。
- ​**​`options`​**​：上述定义的配置项。

**订阅指定 Stream 的消息并自动处理**
 - ​**​其他偏移量选项​**​：
    - `ReadOffset.from("0-0")`：从第一条消息开始消费。
    - `ReadOffset.latest()`：只消费新消息（忽略历史消息）。
```java
streamMessageListenerContainer.receiveAutoAck(
Consumer.from(group, "stats-consumer"),  //定义消费者组和消费者名称
StreamOffset.create(topic, ReadOffset.lastConsumed()), //指定哪个位置开始消费
shortLinkStatsSaveConsumer); //消息到达时的处理逻辑,需实现 `StreamListener`接口或使用 Lambda
```

**具体实现类**
```java
实现 StreamListener接口的方法，当 Redis Stream 中有新消息时自动触发。
@Override
    public void onMessage(MapRecord<String, String, String> message) {
    // 获取 Stream 名称与消息的唯一 ID
        String stream = message.getStream();
    //当生产者通过XADD命令（或 Java 的 redisTemplate.opsForStream().add()）向 Stream 写入消息时，​Redis 会自动为消息分配一个唯一 ID​​。
        RecordId id = message.getId();
        //获取对应的键值对消息
        Map<String, String> producerMap = message.getValue();
        String fullShortUrl = producerMap.get("fullShortUrl");
        //获取成功的情况下
        if (StrUtil.isNotBlank(fullShortUrl)) {
        //提取对应分组
            String gid = producerMap.get("gid");
        //提取数据和之前在隔壁存好的数据
            ShortLinkStatsRecordDTO statsRecord = JSON.parseObject(producerMap.get("statsRecord"), ShortLinkStatsRecordDTO.class);
        //用这个方法实现数据库存储
            actualSaveShortLinkStats(fullShortUrl, gid, statsRecord);
        }
        //删除Redis缓存防止数据堆积
         //**`Objects.requireNonNull(stream)​​
         //- ​**​验证 `stream`参数是否为 `null`​**​。
         //- 如果 `stream`是 `null`，抛出 `NullPointerException`。
         //- 如果 `stream`非 `null`，直接返回该对象（不影响原有逻辑）
         // 等效于： 
         //if (stream == null) { 
         //throw new NullPointerException("stream cannot be null"); 
         //} 
         //stringRedisTemplate.opsForStream().delete(stream, id.getValue());
         
        stringRedisTemplate.opsForStream().delete(Objects.requireNonNull(stream), id.getValue());
    }
```

## 消费队列重复消费问题如何解决
### 需求背景

- 网络问题
- 生产重试

### 解决办法
**幂等**
![[Pasted image 20250814194744.png]]