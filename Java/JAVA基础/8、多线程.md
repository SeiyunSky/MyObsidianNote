进程是程序基本执行实体，线程是操作系统能够进行运算调度的最小单位
**并发：** 多个指令交替执行
**并行：** 多个指令同时执行

### **多线程实现方式**

| 继承Thread类       | 编程比较简单，可以直接使用Thread类中的方法                      | 扩展性较差，不能再继承其他的类                             |
| --------------- | --------------------------------------------- | ------------------------------------------- |
| 实现Runnable接口    | 扩展性强，实现该接口的同时还可以继承其他的类                        | 编程相对复杂，不能直接使用Thread类中的方法                    |
| ​实现Callable接口​​ | 可以获取线程执行结果（通过Future/FutureTask），支持泛型返回值，可抛出异常 | 使用比Runnable复杂，需要配合FutureTask或线程池使用，不能直接启动线程 |

**继承Thread类的方式实现
- 重写Run方法
- 创建子类的对象，启动线程
```java
public class Mythread extends Thread{
   @Override
   public void run(){
     //线程需要执行的代码   
   }
}

MyThread t1 = new MyThread();
//开启线程，线程内会自动跑Run方法
t1.start();
```

**实现Runnable接口的方式**
  - 定义一个类实现Runnable接口
  - 重写里面的run方法
  - 创建自己的类的对象
  - 创建Tread类的对象，开启线程
```java
public class MyClass implements Runnable{
    @Override
    public void run(){
    //执行的代码
    //获取当前只在执行的线程对象
    Thread t = Thread.currentThread();
    }
}

MyClass mr = new MyClass();
//传递对象
Thread t1 = new Thread(mr);

t1.start();
```

**利用Callable接口和Future接口实现**
- 有返回值
- 创建一个实现Callable接口的类
- 重写call()方法，该方法有返回值
- 创建类的对象，创建FutureTask的对象（管理多线程运行的结果）
- 创建Thread的对象
```java
public MyClass implements Callable<结果的类型>{
    @Override
    public 结果的类型 call() throws Exception{
        //实现的任务；
    }
}

MyClass test = new MyClass();
FutureTask<类型> ft = new FutureTask<>(test);
Thread t1 = new Thread(ft);
t1.start();
```

### 常用Thread类成员方法

| 法签名                                  | 功能描述                 |
| ------------------------------------ | -------------------- |
| String **getName()**                 | 返回此线程的名称             |
| void **setName(String name)**        | 设置线程的名字（构造方法也可以设置名字） |
| static Thread **currentThread()**    | 获取当前线程的对象            |
| static void **sleep(long time)**     | 让线程休眠指定的时间，单位为毫秒     |
| **setPriority(int newPriority)**     | 设置线程的优先级             |
| final int **getPriority()**          | 获取线程的优先级             |
| final void **setDaemon(boolean on)** | 设置为守护线程              |
| public static void **yield()**       | 出让线程/礼让线程            |
| public static void **join()**        | 插入线程/插队线程            |
**守护线程**
当其他非守护线程执行完毕后，守护线程会陆续结束，并不会执行完

**出让线程**
在对应的run方法中，写入Thread.yield(); 进行到这里时，会出让一次CPU的执行权

**插入线程**
直接在运行的界面，调用对应线程的join()方法，就可以将该线程一定插入到上面的线程里

**线程的生命周期**
![[Pasted image 20250814145435.png]]
