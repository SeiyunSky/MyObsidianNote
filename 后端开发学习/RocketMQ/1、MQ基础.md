#### **同步调用与异步调用**

| **特性​**​     | ​**​同步调用​**​    | ​**​异步调用​**​       |
| ------------ | --------------- | ------------------ |
| ​**​通信模式​**​ | 直接调用（点对点）       | 通过消息队列中间件（生产者-消费者） |
| ​**​响应方式​**​ | 实时等待结果返回        | 无需立即响应，结果通过回调/轮询获取 |
| ​**​耦合性​**​  | 强耦合（调用方依赖服务方存活） | 解耦（服务宕机不影响消息发送）    |
| ​**​性能影响​**​ | 阻塞线程，高并发时资源占用高  | 非阻塞，吞吐量高           |
| ​**​典型场景​**​ | 支付结果查询、实时数据校验   | 日志收集、短信通知、订单状态同步   |
#### MQ技术选型
![[Pasted image 20250818170515.png|700]]

#### **MQ优势作用**：
**应用解耦**：消费方存活与否不影响生产方

**异步提速**：生产方发完消息，可以继续下一步业务逻辑

**削峰填谷**：高峰期数据积压在MQ中，高峰期后消费速度还是维持在一定水平，填谷，提高系统稳定性

**分布式模式缓存同步**
  一条消息本来只可以被集群的一台机器消费，如果使用 RocketMQ 的广播消费模式，那么这条消息会被所有节点消费一次，相当于把价格信息同步到需要的每台机器上，取代缓存的作用。
**分布式定时/延时调度**
  应用于订单超时中心处理、分布式延时调度系统
  ![[Pasted image 20250819191637.png|300]]

**MQ劣势**：系统可用性降低、复杂度提高（如何保证消息幂等，如何处理消息丢失情况）、一致性问题

#### **RocketMQ基本架构**
**命名服务器集群**和**消息服务器集群**
![[Pasted image 20250819161842.png]]

1. 启动 NameServer
启动 NameServer。NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个路由控制中心。

2. 启动 Broker
启动 Broker。与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。

3. 创建 Topic
创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。

4. 生产者发送消息
生产者发送消息。启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker发消息。

5. 消费者接受消息
消费者接受消息。跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。

#### 启动RocketMQ
1、**NameServer**
 在bin目录下执行cmd命令呼出命令框，执行 start mqnamesrv.cmd
2、**Broker**
 与上述同样的路径下呼出对话框，执行 start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable = true



