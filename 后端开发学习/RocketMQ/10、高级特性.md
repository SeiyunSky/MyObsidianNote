#### 消息存储特性
1、消息生产者发送消息进入MQ
2、消息进行持久化管理，存储该消息
3、MQ返回ACK给生产者
4、MQpush消息给对应消费者
5、消息消费者返回ACK给MQ
6、MQ删除DB内消息
![[Pasted image 20250820180517.png|500]]
**解决办法——采用消息刷盘机制进行数据存储**


#### 高性能写入设计
1、**顺序写入**
- **CommitLog 顺序追加**：所有消息顺序写入单个文件，避免磁盘随机I/O，预先申请了空间进行顺序读写
 **真实消息存放在Broker的磁盘上**

2、**跳过用户态——零拷贝技术（Linux）**
![[Pasted image 20250820181342.png]]
Java中用MappedByteBuffer实现了该技术

3、**消息存储结构**
**MQ数据存储区域**：
- 消息数据存储区——commitlog
    topic
    message
    queueId
- 消费逻辑队列——offset
    min、max offset
    consumeoffset
- 索引
    key索引
    创建时间索引

4、**刷盘机制**
  同步刷盘——异步刷盘
  
5、**高可用性**
![[Pasted image 20250820182217.png]]
## 多NameServer处理机制
在RocketMQ集群中，多个NameServer协同工作但不会造成重复处理消息或性能丢失，原因如下：
1. ​**​无状态设计​**​：NameServer是无状态的，不存储任何消息数据，只维护路由信息
2. ​**​轻量级角色​**​：NameServer主要负责路由管理、Broker状态监测等轻量级工作
3. ​**​最终一致性​**​：多个NameServer之间通过心跳机制保持路由信息的最终一致性
4.  ​**​客户端缓存​**​：生产者和消费者会缓存路由信息，不会频繁访问NameServer
这种设计使得NameServer可以水平扩展，不会成为性能瓶颈。
## Broker从机(Slave)的作用
Broker从机在RocketMQ集群中扮演重要角色：
1. ​**​数据冗余​**​：从机保存与主机相同的消息数据，防止数据丢失
2. ​**​读负载均衡​**​：消费者可以从从机读取消息，分担主机的读压力
3. ​**​故障转移​**​：当主机宕机时，从机可以升级为主机继续提供服务
4. ​**​消息过滤​**​：从机可以处理消息过滤请求，减轻主机负担
5. ​**​HA机制​**​：支持同步/异步复制模式，保证高可用性
## 消息处理避免重复的机制
RocketMQ通过以下机制确保消息不会被重复处理：
1. ​**​主从分工​**​：主机负责写操作，从机负责读操作，职责明确
2. ​**​消息偏移量管理​**​：消费者维护消费进度(offset)，确保消息只被处理一次
3. ​**​事务机制​**​：支持事务消息，保证消息的原子性处理
4. ​**​幂等设计​**​：消费者端应实现幂等处理逻辑

顺序消息，对于同一个消息队列（MessageQueue），RocketMQ 会阻塞该队列的后续消息处理，**直到当前消息被成功消费或达到最大重试次数**，每次等待默认是**3秒**。没有上限，会不断尝试，阻塞住。

无序消息会重复16次，间隔时间越来越长，直到16次。
死信消息：如果16次后还是没有用，就保存到新的队列（Dead-Letter-Queue）只会归属某个组，不会被再次重复消费，保存3天，超过时限后清除。