**引入RocketMQ依赖**
```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.2.3</version>
</dependency>
```
**启动自动装配**
```java
# RocketMQ 2.2.3 version does not adapt to SpringBoot3
org.apache.rocketmq.spring.autoconfigure.RocketMQAutoConfiguration
```
**引入RocketMQ相关配置**
```yaml
server:
  port: 6060

rocketmq:
  name-server: 127.0.0.1:9876 # NameServer 地址
  producer:
    group:  # 全局发送者组定义
```

### **简单生产者**
```java
public class Producer {  
    public static void main(String[] args) throws Exception{  
        //1.创建一个生产者  
        DefaultMQProducer producer = new DefaultMQProducer("group1");  
        //2.设置nameserver  
        producer.setNamesrvAddr("localhost:9876");  
        producer.start();  
        //3，创建一个Message消息  
        String msg = "first message from myself";  
        byte[] bytes = msg.getBytes();  
        Message message = new Message("topic1","tag1", bytes);  
        //4.发送消息写出结果  
        SendResult sendResult = producer.send(message);  
        System.out.println(sendResult);  
        //5.清空内容  
        producer.shutdown();  
    }  
}
```

### 简单消费者
```java
public class Consumer {  
    public static void main(String[] args) throws Exception{  
        //1、获得一个通过push获取消息的消费者  
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("grou1");  
        //2、从对应的nameserver获得消息来源  
        consumer.setNamesrvAddr("localhost:9876");  
        //3、选择监听的消息队列 选择对应topic监听对应数据  
        consumer.subscribe("topic1","*");  
        //4、处理业务流程  
        //返回一个监听者  
        consumer.registerMessageListener(new MessageListenerConcurrently() {  
            @Override  
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {  
                for(MessageExt msg : list){  
                //从MessageEXT中取出数据
                    System.out.println(msg);  
                    byte[] bytes = msg.getBody();  
                    System.out.println(new String(bytes));  
                }  
                //返回枚举类的成功  
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;  
            }  
        });  
        consumer.start();  
        //消费者不要关闭，只要监听到了，就处理，因此需要进行长连接  
    }  
}
```

