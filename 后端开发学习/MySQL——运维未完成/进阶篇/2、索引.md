索引是用于高效获取数据的有序数据结构
**提高检索效率降低更新效率**

## 索引结构
| 索引结构            | 描述                                         |
| --------------- | ------------------------------------------ |
| B+Tree索引        | 最常见的索引类型，大部分引擎都支持B+树索引                     |
| Hash索引          | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询     |
| R-tree(空间索引)    | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES    |

|索引类型|InnoDB|MyISAM|Memory|
|---|---|---|---|
|B+tree索引|✅ 支持|✅ 支持|✅ 支持|
|Hash索引|❌ 不支持|❌ 不支持|✅ 支持|
|R-tree索引|❌ 不支持|✅ 支持|❌ 不支持|
|Full-text|✅ 5.6版本后支持|✅ 支持|❌ 不支持|

Mysql中的B+Tree修改为了双向链表指针

## 索引分类
| 分类     | 含义                         | 特点                    | 关键字      |
| ------ | -------------------------- | --------------------- | -------- |
| 主键索  引 | 针对表中主键创建的索引                | 默认自动创建，每个表只能有一个       | PRIMARY  |
| 唯一索引   | 避免同一个表中某数据列中的值重复           | 可以有多个，允许NULL值但不计入重复判断 | UNIQUE   |
| 常规索引   | 用于快速定位特定数据                 | 可以创建多个，无特殊约束          | （无）      |
| 全文索引   | 查找文本中的关键词（基于分词），而不是直接比较索引值 | 可以有多个，适用于大文本字段        | FULLTEXT |

回表查询：通过二级索引找到聚集索引寻找对应数据
二级索引会让查询变成logn，适合大数据情况下对经常查找的数据列使用

| 分类   | 含义                   | 特点                                 |
| ---- | -------------------- | ---------------------------------- |
| 聚集索引 | 数据行直接存储在索引结构的叶子节点中   | • 每个表必须有且仅有一个  <br>• 物理存储顺序与索引顺序一致 |
| 二级索引 | 索引叶子节点存储的是主键引用，需回表查询 | • 一个表可创建多个  <br>• 查询时可能产生回表操作      |
## 语法
**创建索引**
```mysql
create [UNIQUE|FULLTEXT] INDEX 索引名 ON 表名(列名称...)
```
**删除索引**
```mysql
drop INDEX 索引名 ON 表名
```

**案例**
```mysql
1. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。
    create index idx_user_name on user (name);
2. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。
    create UNIQUE index idx_user_phone on user(phone);
3. 为profession、age、status创建联合索引。
    create index idx_user_pro_age_sta on user(profession,age,status)
4. 为email建立合适的索引来提升查询效率。
    create index idx_user_email on user(email)
```

## SQL性能分析工具
- SQL执行频率
```mysql
查询当前数据库crud频率
show [session|global] status

用法
show global status like 'com_______'
```

- 慢查询日志
 执行时间超过指定参数(默认10s)后，会定义为慢查询
 ```config
 默认关闭，需要在/etc/my.cnf文件中配置如下信息
 slow_query_log = 1
 long_query_time = ?

慢日志文件中记录的信息存放在
/var/lib/mysql/localhost-slow.log
```

- **explain执行计划**
```mysql
直接在任意select语句前加上关键词Explain
explain select 字段列表 from 表 where 条件;
```

其中：
```
id 
用来说明表的执行顺序，往往和where有关，id越大越先执行

select_type 
查看查询类型

type 表示连接类型，性能由好到坏为
NULL ,SYSTEM ,CONST ,EQ_REF ,REF ,RANGE ,INDEX ,ALL

possible_key 
可能应用在该表的索引

Key
实际用到的索引，如果为NULL，则没有使用索引

Key_len 
表示索引中使用的字节数

Rows
可能要执行查询的行数

fltered
返回结果占需求rows的百分比，理解为召回率就行
```

## 索引使用规则

- 最左前缀法则
    如果索引了多列，要遵循最左前缀法则，**查询从索引的最左列开始，且不跳过索引中的列**（跳过会导致部分失效发生）
- SQL提示
    用于影响查询执行计划的选择
```mysql
SELECT * FROM table_name USE INDEX(index_name) WHERE condition;
SELECT * FROM table_name IGNORE INDEX(index_name) WHERE condition;
SELECT * FROM table_name FORCE INDEX(index_name) WHERE condition;
```
- 覆盖索引
    **覆盖索引​**​是指一个索引包含了查询所需的所有字段，使得数据库引擎只需访问索引而无需回表就能完成查询。
- 前缀索引
    前缀索引是一种特殊的索引类型，**它只对列值的前面部分字符建立索引**，而不是整个列值。这种索引在特定场景下能显著节省存储空间并提高查询性能。
```mysql
-- 为name字段前5个字符创建索引
CREATE INDEX idx_name_prefix ON table_name(name(5));
-- 为email字段前10个字符创建索引
ALTER TABLE table_name ADD INDEX idx_email_prefix(email(10));
```
**解决超大分页方法：**
```mysql
深度分页查询优化语句
子查询+覆盖索引方法
select * 
from tb_sku t, 
(select id from tb_sku order by id limit 9000000,10) a 
where t.id = a.id;
```

**索引失效情况**
    在索引列上进行运算操作
    字符串不加引号
- 模糊查询
    头部只要不进行模糊查询就不会失效，反之索引失效
- or连接条件
    用or分割开的情况下， 如果前列有索引后列没有，那么索引全部失效
- 数据分布影响 
    铸币做的索引效率还不如不用


![[Pasted image 20250803161059.png]]


