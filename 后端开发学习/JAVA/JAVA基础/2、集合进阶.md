![[Pasted image 20250729153551.png]]
# **集合体系结构**
## 单列集合 Collection
**红色为接口，蓝色为实现类**
List：有序、可重复、有索引
Set：无序、不重复、无索引
![[Pasted image 20250728201514.png]]
```JAVA
Collection 接口
public interface Collections<E> {
    // 1. 添加元素到集合
    public boolean add(E e); 

    // 2. 清空集合
    public void clear(); 

    // 3. 删除指定元素
    public boolean remove(E e); 

    // 4. 判断是否包含元素
    public boolean contains(Object obj); 

    // 5. 判断集合是否为空
    public boolean isEmpty(); 

    // 6. 获取集合大小
    public int size(); 
}
```
```java
创建方法
Collections<T> ret = new ArrayList();
```
#### 遍历方式
**迭代器**
迭代器遍历完毕后不会复位，且循环中只能使用一次next方法
```JAVA
获取迭代器对象
Iterator<T> it = ret.iterator();
while(it.hasNext()){
    进行操作;
}
```
**增强for**
修改增强for中的变量不会改变原本集合中的数据
```java
for(元素数据类型 变量名：数组或集合){

}

for(String s:list){

}
```
**Lambda表达式**
```java
ret.forEach(s -> 语句);
```
### List 特有的部分
```java
add(int index,E element);
remove(int index);
set(int index,E element);
get(int index);
```
**列表迭代器**
```java
boolean hasNext();
E next();
boolean hasPrevious();
E previous();
int nextIndex();
int previousIndex();

ListIterator<String> listIterator=list.listIterator();

while(listIterator.hasNext()) {
String lement=listIterator.next();
System.out.println(element);
}
```
**StreamAPI迭代**
```java
list.stream().forEach(element -> System.out.println(element));
```

### List接口下的实现
这两个都**非线程安全**
#### Arraylist
Arraylist底层为数组结构
1、空参创建的集合在底层创建一个默认长度为10的数组
2、添加第一个元素时，底层创建一个新的长度为10的数组
3、存满后自动扩容1.5倍
    **计算新的容量**：一般情况下，新的容量会扩大为原容量的1.5倍，然后检查是否超过了最大容量限制。
    **创建新的数组**：根据计算得到的新容量，创建一个新的更大的数组。
    **将元素复制**：将原来数组中的元素逐个复制到新数组中。
    **更新引用**：将ArrayList内部指向原数组的引用指向新数组。完成扩容：扩容完成后，可以继续添加新元素。
4、若扩容1.5放不下，长度会以原本长度为基准

**线程安全怎么弄**
用Collections类的synchronizedList方法可以将ArrayList包装成线程安全的List
```java
List<String> synchronizedList = Collections.synchronizedList(arrayList);
```
或者用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：
```java
CopyOnWriteArrayList<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>(arrayList);
这个里面在写入操作中加上了一个互斥锁
```
Vector也可以用，但这个非常老旧了

**高并发下，ArrayList会出现：**
- 部分值为null（我们并没有add null进去）
- 索引越界异常
- size与我们add的数量不符
    size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的
#### LinkedList
底层为双链表，查询慢，增删快，操作的为首尾快
![[Pasted image 20250729144041.png|600]]

### SET特有的部分
**平衡二叉树算法**
- **左旋和右旋**
  ![[Pasted image 20250729144628.png]]
**左左-右旋，左右-左旋右旋，右右-左旋，右左-右旋左旋**
```java
	class AVLNode {
	    int val, height;
	    AVLNode left, right;
	    
	    AVLNode(int val) {
	        this.val = val;
	        this.height = 1;
	    }
	}
	
	public class AVLTree {
	    private AVLNode root;
	    
	    // 获取节点高度
	    private int height(AVLNode node) {
	        return node == null ? 0 : node.height;
	    }
	    
	    // 计算平衡因子
	    private int balanceFactor(AVLNode node) {
	        return height(node.left) - height(node.right);
	    }
	    
	    // 右旋（RR型）
	    private AVLNode rightRotate(AVLNode y) {
	        AVLNode x = y.left;
	        AVLNode T2 = x.right;
	        
	        x.right = y;
	        y.left = T2;
	        
	        y.height = Math.max(height(y.left), height(y.right)) + 1;
	        x.height = Math.max(height(x.left), height(x.right)) + 1;
	        
	        return x;
	    }
	    
	    // 左旋（LL型）
	    private AVLNode leftRotate(AVLNode x) {
	        AVLNode y = x.right;
	        AVLNode T2 = y.left;
	        
	        y.left = x;
	        x.right = T2;
	        
	        x.height = Math.max(height(x.left), height(x.right)) + 1;
	        y.height = Math.max(height(y.left), height(y.right)) + 1;
	        
	        return y;
	    }
	    
	    // 插入节点
	    public void insert(int val) {
	        root = insert(root, val);
	    }
	    
	    private AVLNode insert(AVLNode node, int val) {
	        if (node == null) return new AVLNode(val);
	        
	        if (val < node.val) {
	            node.left = insert(node.left, val);
	        } else if (val > node.val) {
	            node.right = insert(node.right, val);
	        } else {
	            return node; // 不允许重复值
	        }
	        
	        // 更新高度
	        node.height = 1 + Math.max(height(node.left), height(node.right));
	        
	        // 平衡调整
	        int bf = balanceFactor(node);
	        
	        // LL型
	        if (bf > 1 && val < node.left.val) {
	            return rightRotate(node);
	        }
	        // RR型
	        if (bf < -1 && val > node.right.val) {
	            return leftRotate(node);
	        }
	        // LR型
	        if (bf > 1 && val > node.left.val) {
	            node.left = leftRotate(node.left);
	            return rightRotate(node);
	        }
	        // RL型
	        if (bf < -1 && val < node.right.val) {
	            node.right = rightRotate(node.right);
	            return leftRotate(node);
	        }
	        
	        return node;
	    }
	    
	    // 中序遍历（验证平衡性）
	    public void inorder() {
	        inorder(root);
	    }
	    
	    private void inorder(AVLNode node) {
	        if (node != null) {
	            inorder(node.left);
	            System.out.print(node.val + " ");
	            inorder(node.right);
	        }
	    }
	}
	```
**红黑树**

**HashSet和LinkedHashSet**
基于set和哈希表实现

**TreeSet**
基于红黑树实现
数值默认从小到大，字符默认按ASCII码表中数字升序排序
```java
利用TreeSet存储整数并进行排序
TreeSet<Integer> ts = new TreeSet<>();
内部必然有序，Collection遍历方法都能遍历

存入字符串，按长度排序，若长度一样按首字母排序
TreeSet<String> ts = new TreeSet<>(new Comparator<String>() { @Override 
public int compare(String o1, String o2) { // 按照长度排序
int i = o1.length() - o2.length(); // 如果一样长则按照首字母排序
i = i == 0 ? o1.compareTo(o2) : i; return i; } 
});
```
## 双列集合 Map

![[Pasted image 20250729150654.png]]
```java
Map 接口
public interface Map<K, V> {
    // 1. 添加键值对到映射
    //键如果存在，直接覆盖对应的数值
    public V put(K key, V value);

    // 2. 根据键删除键值对
    public V remove(Object key);

    // 3. 清空映射
    public void clear();

    // 4. 判断是否包含指定的键
    public boolean containsKey(Object key);

    // 5. 判断是否包含指定的值
    public boolean containsValue(Object value);

    // 6. 判断映射是否为空
    public boolean isEmpty();

    // 7. 获取映射的大小（键值对数量）
    public int size();
}

Map<String,String> m = new HashMap<>()
```
### 遍历方法
**键找值**
将键放入单列集合，根据键get对应的值
```java
Set<String> keys = map.keySet();
```
**键值对对象**
```java
Set<Map.Entry<String,String>> entries = map.entrySet();
```
**Lambda表达式**
```java
map.forEach(new BiConsumer<String,String>(){
    @Override
    public void accept(String key,String value) {
        System.out.println(key + "=" + value);
    }
});

map.forEach((key,value)->System.out.println(key+"="+value));
```

### **HashMap 特点**
HashMap线程不安全，效率高，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。
### **LinkedHashMap 特点**
 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。

### **TreeMap 特点**
 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。