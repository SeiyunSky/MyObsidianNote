## 1. 内置锁(synchronized)

Java最基本的锁机制，使用`synchronized`关键字实现：

```java
// 同步方法
public synchronized void method() {
    // 同步代码
}

// 同步代码块
public void method() {
    synchronized(this) {
        // 同步代码
    }
}
```
特点：
- 自动获取和释放锁
- 可重入（同一线程可多次获取同一锁）
- 非公平锁（不保证等待线程的获取顺序）
## 2. ReentrantLock

`java.util.concurrent.locks.ReentrantLock`是更灵活的锁实现：

``` java
Lock lock = new ReentrantLock();

public void method() {
    lock.lock();
    try {
        // 临界区代码
    } finally {
        lock.unlock();
    }
}
```

特点：
- 可重入
- 可选择公平或非公平模式
- 支持尝试获取锁（tryLock）
- 支持可中断的获取锁（lockInterruptibly）
- 支持超时获取锁
## 3. ReadWriteLock

`ReentrantReadWriteLock`实现了读写分离：

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();

// 读操作
public void read() {
    rwLock.readLock().lock();
    try {
        // 读操作
    } finally {
        rwLock.readLock().unlock();
    }
}

// 写操作
public void write() {
    rwLock.writeLock().lock();
    try {
        // 写操作
    } finally {
        rwLock.writeLock().unlock();
    }
}
```

特点：
- 读锁共享，写锁独占
- 写锁降级为读锁（但不能升级）
- 提高读多写少场景的性能

## 4. StampedLock
读的时候不上锁，只有在发现有人写了，再加读锁
乐观锁的缺点是，如果版本号不对，会导致一定情况下读失败，因此在写经常发生的情况下，乐观锁大量导致的读失败是缺点
```java
StampedLock lock = new StampedLock();

// 乐观读
public void optimisticRead() {
    //获取当前版本号
    long stamp = lock.tryOptimisticRead();
    // 读操作，判断版本号是否正确
    if (!lock.validate(stamp)) {
        // 乐观读失败，转为悲观读
        stamp = lock.readLock();
        try {
            // 读操作
        } finally {
            lock.unlockRead(stamp);
        }
    }
}

// 写操作
public void write() {
    long stamp = lock.writeLock();
    try {
        // 写操作
    } finally {
        lock.unlockWrite(stamp);
    }
}
```

特点：
- 支持乐观读（不阻塞写操作）
- 性能通常优于ReentrantReadWriteLock
- 不可重入
- 不支持条件变量

## 5. 条件变量(Condition)

与锁配合使用的线程通信机制：

```java
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();

public void await() throws InterruptedException {
    lock.lock();
    try {
        condition.await(); // 释放锁并等待
    } finally {
        lock.unlock();
    }
}

public void signal() {
    lock.lock();
    try {
        condition.signal(); // 唤醒一个等待线程
    } finally {
        lock.unlock();
    }
}
```
## 锁的选择建议

1. 简单同步场景：优先使用`synchronized`
2. 需要高级功能（如可中断、超时、公平性）：使用`ReentrantLock`
3. 读多写少场景：考虑`ReadWriteLock`或`StampedLock`