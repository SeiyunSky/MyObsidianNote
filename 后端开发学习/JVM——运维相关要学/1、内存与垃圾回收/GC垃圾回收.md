### 方法区的回收
![[Pasted image 20250823215157.png]]

### **堆回收**
如果将a1和b1都置为null，堆内存的对象也能被回收
因为方法中已经没有办法使用引用区方位A和B对象了
![[Pasted image 20250823220655.png]]
##### 判断方法：
**引用计数器法**
**原理**：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。
**缺点**：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。
**可达性分析法**
**原理**：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。


### 垃圾回收算法
![[Pasted image 20250823224407.png]]
**标记清除算法**
![[Pasted image 20250823230817.png]]
![[Pasted image 20250823230839.png]]

**复制算法**
![[Pasted image 20250823231552.png]]
![[Pasted image 20250823231642.png]]

**标记整理算法**
![[Pasted image 20250823231750.png]]

**分代垃圾回收算法**
![[Pasted image 20250823232744.png]]![[Pasted image 20250823233007.png]]
分代目的是为了提高整体效率，通过将堆分为新生代和老年代，用来适应不同的应用程序，对于新生代往往使用复制算法，速度快，stw时间短，老年代往往选择标记-清除整理算法相关。
分代的设计中允许只回收minor gc，能满足对象分配的要求就不需要对整个堆进行回收，STW时间就会减少。

### 垃圾回收器
![[Pasted image 20250824141538.png]]

**单线程垃圾回收器**
![[Pasted image 20250824141645.png]]
![[Pasted image 20250824141835.png]]


**ParNew +CMS**
![[Pasted image 20250824142255.png]]
![[Pasted image 20250824142328.png]]
只会在**初始标记**和**重新标记**阶段产生STW


**Parallel Scanvenge+Parallel Old**
![[Pasted image 20250824144326.png]]![[Pasted image 20250824144446.png]]

### **G1垃圾回收器**
![[Pasted image 20250824145014.png]]
![[Pasted image 20250824145710.png]]
![[Pasted image 20250824150053.png]]
混合回收过程中和CMS的回收阶段基本差不多，但G1(Garbage first)的标记清理逻辑**选择存活度最低的区域**进行回收，但是最终标记阶段不管新创建和不再管理的对象，**并发清理阶段采用的是复制算法**，**不会产生内存碎片**。
