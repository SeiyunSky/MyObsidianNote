### 方法区的回收
![[Pasted image 20250823215157.png]]

### **堆回收**
如果将a1和b1都置为null，堆内存的对象也能被回收
因为方法中已经没有办法使用引用区方位A和B对象了
![[Pasted image 20250823220655.png]]
##### 判断方法：
**引用计数器法**
**原理**：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。
**缺点**：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。
**可达性分析法**
**原理**：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。


### 垃圾回收算法
![[Pasted image 20250823224407.png]]
**标记清除算法**
![[Pasted image 20250823230817.png]]
![[Pasted image 20250823230839.png]]

**复制算法**
![[Pasted image 20250823231552.png]]
![[Pasted image 20250823231642.png]]

**标记整理算法**
![[Pasted image 20250823231750.png]]

**分代垃圾回收算法**
![[Pasted image 20250823232744.png]]![[Pasted image 20250823233007.png]]
