对于图来说，表示方式是
**邻接表**
List<List\<Integer>>
Map<Integer, List\<Integer>>
List<Set\<Integer>>
**邻接矩阵**
int\[]\[]
boolean\[]\[]
List<List\<Edge>>
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        //输出所有的可达路径
        //从1开始到n的位置，我需要先做一个联系
        List<List<Integer>> store = new ArrayList<>();
        for(int i = 0;i < n;i++){
            store.add(new ArrayList<>());
        }
        while(sc.hasNextInt()){
            int pre = sc.nextInt();
            int post = sc.nextInt();
            store.get(pre - 1).add(post);
        }
        List<List<Integer>> allPaths = findAllPaths(store, 1, n);
        if(allPaths.isEmpty()){
             System.out.print(-1);
        }
        // 输出所有路径
        for (List<Integer> path : allPaths) {
            for (int i = 0; i < path.size(); i++) {
                System.out.print(path.get(i));
                if (i < path.size() - 1) {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    // DFS 查找所有路径
    public static List<List<Integer>> findAllPaths(List<List<Integer>> graph, int start, int end) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentPath = new ArrayList<>();
        currentPath.add(start);
        dfs(graph, start, end, currentPath, result);
        return result;
    }
    
    private static void dfs(List<List<Integer>> graph, int current, int end, List<Integer> currentPath, List<List<Integer>> result) {
        if (current == end) {
            result.add(new ArrayList<>(currentPath)); // 找到一条完整路径
            return;
        }
        for (int neighbor : graph.get(current - 1)) { // 遍历邻接节点
            if (!currentPath.contains(neighbor)) { // 避免环
                currentPath.add(neighbor);
                dfs(graph, neighbor, end, currentPath, result);
                currentPath.remove(currentPath.size() - 1); // 回溯
            }
        }
    }
}
```